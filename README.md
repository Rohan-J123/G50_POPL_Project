# G50_POPL_Project

## COMPARISON OF PROGRAMMING CONSTRUCTS BETWEEN C++ AND C#

### Names of Group Members:-

Rohan Jha: 2021A7PS2721G

Atharva Sunder: 2021A7PS0391G

Aaryan Jain: 2021A7PS2060G

Urav Bhatt: 2021A7PS3057G


### Problem Statement:-

When you switch devices, especially between different architectures or operating systems, you may need to recompile your C++ source code for several reasons:

1. Architecture Differences: Different devices may have different architectures (e.g., x86, ARM), and binaries compiled for one architecture may not be compatible with another. The machine code generated by the compiler is specific to the target architecture. So, when you switch devices with different architectures, you need to recompile your code to generate the correct machine code for the new architecture.

2. Operating System Differences: If you switch between different operating systems, the system libraries and APIs may vary. The C++ standard library, for example, may have different implementations on different operating systems. Recompiling ensures that your code is linked against the correct libraries and uses the appropriate system calls for the target operating system.

3. Compiler Differences: Even if the architecture and operating system are the same, different devices may use different compilers or compiler versions. Compilers may have variations in how they implement language features or optimizations. Recompiling ensures that your code is compatible with the specific compiler on the new device.

4. Dependencies: If your C++ code depends on external libraries or frameworks, those libraries may need to be recompiled for the target device. Different devices may have different versions of libraries or dependencies, and recompiling ensures that your code uses the correct versions.

5. Target Platform-Specific Optimizations: Compilers often apply optimizations based on the target platform. Recompiling allows the compiler to take advantage of the specific features and optimizations available on the new device.

In summary, recompilation is necessary to adapt your C++ code to the specific characteristics of the target device, including its architecture, operating system, compiler, and any dependencies. This process ensures that the generated binary is compatible and optimized for the new environment. This hinders cross-platform development, and hence in this project we will demonstrate how the programming construct of C# gives us an advantage over C++ in this context.


### Software Architecture:-

C# is a language designed to be platform-independent, and it runs on the Common Language Runtime (CLR), which abstracts away many of the low-level details related to the underlying hardware and operating system. This design choice contributes to the portability of C# code across different devices without the need for recompilation in many cases. Here are some reasons why C# files generally don't need to be recompiled when switching devices:

1. Intermediate Language (IL): When you compile a C# program, the output is not native machine code but rather an intermediate language called Common Intermediate Language (CIL) or Microsoft Intermediate Language (MSIL). This intermediate code is then executed by the CLR at runtime. This level of abstraction allows the code to be platform-independent.

2. Just-In-Time Compilation (JIT): The CLR uses a Just-In-Time (JIT) compiler to translate the intermediate code into native machine code at runtime. This compilation happens on the target device, taking into account the specific characteristics of the device, such as its architecture and operating system. This process is part of the reason why C# applications can be executed on different platforms without recompilation.

3. Managed Execution Environment: C# programs run in a managed execution environment provided by the CLR. The CLR is responsible for memory management, garbage collection, and other runtime services. This managed environment shields the code from direct interaction with the underlying hardware, making it more portable.

4. Platform Abstraction: C# abstracts away many platform-specific details, and the .NET Framework (or .NET Core/.NET 5 and later) provides a consistent set of libraries and APIs across different platforms. As long as the necessary runtime and framework components are available on the target device, C# code can run without modification.

Therefore, the combination of JIT compilation, platform abstraction, and a managed runtime environment contributes to the cross-platform capabilities of C# without requiring recompilation for each device.


### POPL Aspects:-

* C# is Concept-Oriented Language (Describes how objects arerepresented and accessed. It makes references (object locations) responsible for many important functions which are difficult tomodel via objects) while C++ is an Object-Oriented language.

* Memory management is C++ is done by programmer manually, i.e if an object is created, it must be destroyed by the programmer. C# handles memory by using garbage collectors, which will automatically trash a created object once the object’s task is complete. 

* Compiler in C++ does bound memory check in arrays. If programmer accesses a wrong array index, compilation error will occur. Compiler in C++ doesn’t perform bound check. Hence, illegal array index will lead to incorrect result or compilation faults. 

* C# has a separate safe and unsafe mode. In unsafe mode, sectionof C# isn’t managed by Common Runtime(CLR) of .NET framework. Pointers aren’t allowed by default in C# but can be used in unsafemode. C# behaves as C++ in unsafe mode.

* C++ compiles to machine code, while C# compiles to CLR (CommonLanguage Runtime) which is interpreted by JIT in ASP.NET. C# can compile codes faster than C++. This process is what makes C# files platform-independent.


### Results:-

To show comparative study between C++ and C#, we have written simple bubble sorting algorithm in both the languages.
### Potential For Future Work:-

While C# has a lot of advantages over C++, it also has a few disadvantages:-

* Since C# is part of the .NET ecosystem, its applications are almost exclusively for Windows-based systems. Although Microsoft is attempting to make it universal, major OS don’t support C#.

* Multiple inheritance through classes isn’t supported by C# while it issupported in C++.

* While C# is versatile and can serve quite a number of projects, that ability comes with a caveat: you need the .NET framework to make it all run smoothly. This also makes it a little slower than C and C++.

* C# is a high-level language, which doesn’t just mean that syntax and coding approaches are more abstract but also that interfacing C# products with hardware is impossible.